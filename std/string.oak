/*
Jordan Dehmel, 2023

Basic non-resizing heap string.
*/

package!("std");

let string: struct
{
    data: ^i8,
    size: u128,
}

let New(self: ^string) -> void
{
    self.size = to_u128(0);
}

let Copy(self: ^string, size: u128) -> void
{
    // Clear self if needed
    if (self.size != to_u128(0))
    {
        free_arr!(self.data);
        self.size = to_u128(0);
    }

    self.size = size;
    alloc!(self.data, self.size);
}

let Copy(self: ^string, from: str) -> void
{
    // Clear self if needed
    if (self.size != to_u128(0))
    {
        free_arr!(self.data);
        self.size = to_u128(0);
    }

    // Poll size of from (including null termination)
    let size: u128;
    size = to_u128(0);
    while (Get(@from, size) != to_i8(0))
    {
        size += to_u128(1);
    }

    // Alloc self
    self.size = size;
    alloc!(self.data, self.size);

    // Copy data (including null termination)
    while (size != to_u128(0))
    {
        Copy(Get(@self.data, size), Get(@from, size));

        size -= to_u128(1);
    }
    Copy(Get(@self.data, to_u128(0)), Get(@from, to_u128(0)));
}

let Copy(self: ^string, from: string) -> void
{
    // Clear self if needed
    if (self.size != to_u128(0))
    {
        free_arr!(self.data);
        self.size = to_u128(0);
    }

    // Poll size of from (including null termination)
    let size: u128;
    size = to_u128(0);
    while (^Get(@from.data, size) != to_i8(0))
    {
        size += to_u128(1);
    }

    // Alloc self
    self.size = size;
    alloc!(self.data, self.size);

    // Copy data (including null termination)
    while (size != to_u128(0))
    {
        Copy(Get(@self.data, size), ^Get(@from.data, size));

        size -= to_u128(1);
    }
    Copy(Get(@self.data, to_u128(0)), ^Get(@from.data, to_u128(0)));
}

let Del(self: ^string) -> void
{
    free_arr!(self.data);
    self.size = to_u128(0);
}

let clear(self: ^string) -> void
{
    let i: u128;
    i = to_u128(0);

    while (i < self.size)
    {
        Copy(Get(@self.data, i), to_i8(0));

        i += to_u128(1);
    }
}

let Eq(self: ^string, other: string) -> bool
{
    let out: bool;
    out = true;

    if (self.size != other.size)
    {
        out = false;
    }
    else
    {
        let cur: u128;
        cur = to_u128(0);

        while (cur < self.size)
        {
            if (^Get(@self.data, cur) != ^Get(@self.data, cur))
            {
                out = false;
                cur = self.size;
            }
        }
    }

    out
}

let Neq(self: ^string, other: string) -> bool
{
    let out: bool;
    out = Eq(self, other);

    if (out)
    {
        out = false;
    }
    else
    {
        out = true;
    }

    out
}

let Get(self: ^string, index: u128) -> ^i8
{
    Get(@self.data, index)
}

let Copy(self: ^string, from: string) -> void
{
    // Clear self if needed
    if (self.size != to_u128(0))
    {
        free_arr!(self.data);
        self.size = to_u128(0);
    }

    // Alloc self
    self.size = from.size;
    alloc!(self.data, self.size);

    // Copy data (including null termination)
    let i: u128;
    i = self.size;
    while (i != to_u128(0))
    {
        Copy(Get(@self.data, i), ^Get(@from, i));

        i -= to_u128(1);
    }
    Copy(Get(@self.data, to_u128(0)), ^Get(@from, to_u128(0)));
}

let print(what: string) -> void
{
    let i: u128;
    i = to_u128(0);
    while (i < what.size())
    {
        print(^Get(@what.data, i));
        
        i += to_u128(1);
    }
}

let Add(a: string, b: string) -> string
{
    let out: string;

    // Accounts for null termination
    let size: u128;
    size = a.size + b.size;

    Copy(@out, size);

    let i: u128;
    i = to_u128(0);

    while (i < a.size)
    {
        Copy(Get(@out.data, i), ^Get(@a.data, i));

        i += to_u128(1);
    }

    let b_pos: u128;
    b_pos = to_u128(0);

    while (b_pos < b.size)
    {
        Copy(Get(@out.data, i), ^Get(@b.data, b_pos));

        b_pos += to_u128(1);
        i += to_u128(1);
    }

    out
}
