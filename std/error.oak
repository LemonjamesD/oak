/*
Standard error 
*/

package!("std");
include!("std/string.oak");
include!("std/printf.oak");

use_rule!("std");

// Canonical form: Unit string ""
let error_str: string;

// Canonical form: Unit int 0
let error_code: i128;

let error_state: struct
{
    message: string,
    code: i128,
}

let New(self: ^error_state) -> void
{
    New(@self.message);
    New(@self.code);
}

let Copy(self: ^error_state, message: string, code: i128) -> void
{
    self.message = message;
    self.code = code;
}

let Copy(self: ^error_state, other: error_state) -> void
{
    self.message = other.message;
    self.code = other.code;
}

let get_error_state() -> error_state
{
    let out: error_state;

    out.code = error_code;
    out.message = error_str;

    out
}

// Returns true if there is a change in error state between the current error
// and a given one
let poll_error_change(prev: error_state) -> bool
{
    let out: bool = false;

    if prev.code != error_code
    {
        out = true;
    }
    else if prev.message != error_str
    {
        out = true;
    }

    out
}

// For stack-restores
let restore_error_state(state: ^error_state) -> void
{
    error_str = state.message;
    error_code = state.code;
}

// Resets any errors
let reset_error() -> void
{
    error_str = "";
    error_code = to_i128(0);
}

// For error throwing, obviously
let throw_error(message: string, code: i128) -> void
{
    error_str = message;
    error_code = code;
}

let throw_error(message: string) -> void
{
    error_str = message;
    error_code = to_i128(0);
}

let throw_error(code: i128) -> void
{
    error_str = "";
    error_code = code;
}

let throw_error(message: str, code: i128) -> void
{
    error_str = message;
    error_code = code;
}

let throw_error(message: str) -> void
{
    error_str = message;
    error_code = to_i128(0);
}
