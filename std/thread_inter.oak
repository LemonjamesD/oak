/*
Jordan Dehmel, 2023

Basic Oak multithreading functions and
objects.

As of 0.0.10, mutex is experimental.
*/

link!("std/thread_inter.o");
include!("std/opt.oak");

// Mutex (experimental)
let mutex<t>: struct
{
    in_use: bool,
    data: t,
}
needs
{
}

let wait_for_lock<t>(self: ^mutex<t>) -> void
{
    while (self.in_use)
    {
        ;
    }
}

let get_data<t>(self: ^mutex<t>, into: ^^t) -> bool
{
    let out: bool;
    if (self.in_use)
    {
        out = false;
    }
    else
    {
        out = true;

        self.in_use = true;
        ^into = @data;
    }

    out
}

let return_data<t>(self: ^mutex<t>, into: opt<^t>) -> void
{
    ^into = 0;
    self.in_use = false;
}

/////////////////////////////////////////////////////////

// Threads
let thread: struct
{
    // C++ member padding; Don't mess with
    __a, __b, __c, __d: i128,
}

// Defined in C++
let ExtInit(self: ^thread) -> void;
let start(self: ^thread, to_do: ^() -> void) -> void;
let join(self: ^thread) -> void;

let New(self: ^thread) -> void
{
    ExtInit(self);
}

let Del(self: ^thread) -> void
{
    join(self);
}
