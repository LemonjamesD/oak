/*
Jordan Dehmel, 2023
GPLv3

Function signatures for ALL the integer
operators.
*/

link!(int_math.o);

// u8
let u8.Add(self: u8, other: u8) -> u8;
let u8.Sub(self: u8, other: u8) -> u8;
let u8.Mult(self: u8, other: u8) -> u8;
let u8.Div(self: u8, other: u8) -> u8;
let u8.Mod(self: u8, other: u8) -> u8;
let u8.Xor(self: u8, other: u8) -> u8;
let u8.Eq(self: u8, other: u8) -> bool;
let u8.Neq(self: u8, other: u8) -> bool;
let u8.Less(self: u8, other: u8) -> bool;
let u8.Great(self: u8, other: u8) -> bool;
let u8.Leq(self: u8, other: u8) -> bool;
let u8.Greq(self: u8, other: u8) -> bool;
let u8.And(self: u8, other: u8) -> u8;
let u8.Or(self: u8, other: u8) -> u8;
let u8.Lbs(self: u8, other: u8) -> u8;
let u8.Rbs(self: u8, other: u8) -> u8;

let u8.Incr(self: *u8) -> u8;
let u8.Decr(self: *u8) -> u8;

let u8.New(self: *u8) -> void;
let u8.Copy(self: *u8, other: u8) -> u8;
let u8.AddEq(self: *u8, other: u8) -> u8;
let u8.SubEq(self: *u8, other: u8) -> u8;
let u8.MultEq(self: *u8, other: u8) -> u8;
let u8.DivEq(self: *u8, other: u8) -> u8;
let u8.ModEq(self: *u8, other: u8) -> u8;
let u8.AndEq(self: *u8, other: u8) -> u8;
let u8.OrEq(self: *u8, other: u8) -> u8;
let u8.XorEq(self: *u8, other: u8) -> u8;

// u16
let u16.Add(self: u16, other: u16) -> u16;
let u16.Sub(self: u16, other: u16) -> u16;
let u16.Mult(self: u16, other: u16) -> u16;
let u16.Div(self: u16, other: u16) -> u16;
let u16.Mod(self: u16, other: u16) -> u16;
let u16.Xor(self: u16, other: u16) -> u16;
let u16.Eq(self: u16, other: u16) -> bool;
let u16.Neq(self: u16, other: u16) -> bool;
let u16.Less(self: u16, other: u16) -> bool;
let u16.Great(self: u16, other: u16) -> bool;
let u16.Leq(self: u16, other: u16) -> bool;
let u16.Greq(self: u16, other: u16) -> bool;
let u16.And(self: u16, other: u16) -> u16;
let u16.Or(self: u16, other: u16) -> u16;
let u16.Lbs(self: u16, other: u16) -> u16;
let u16.Rbs(self: u16, other: u16) -> u16;

let u16.Incr(self: *u16) -> u16;
let u16.Decr(self: *u16) -> u16;

let u16.New(self: *u16) -> void;
let u16.Copy(self: *u16, other: u16) -> u16;
let u16.AddEq(self: *u16, other: u16) -> u16;
let u16.SubEq(self: *u16, other: u16) -> u16;
let u16.MultEq(self: *u16, other: u16) -> u16;
let u16.DivEq(self: *u16, other: u16) -> u16;
let u16.ModEq(self: *u16, other: u16) -> u16;
let u16.AndEq(self: *u16, other: u16) -> u16;
let u16.OrEq(self: *u16, other: u16) -> u16;
let u16.XorEq(self: *u16, other: u16) -> u16;

// u32
let u32.Add(self: u32, other: u32) -> u32;
let u32.Sub(self: u32, other: u32) -> u32;
let u32.Mult(self: u32, other: u32) -> u32;
let u32.Div(self: u32, other: u32) -> u32;
let u32.Mod(self: u32, other: u32) -> u32;
let u32.Xor(self: u32, other: u32) -> u32;
let u32.Eq(self: u32, other: u32) -> bool;
let u32.Neq(self: u32, other: u32) -> bool;
let u32.Less(self: u32, other: u32) -> bool;
let u32.Great(self: u32, other: u32) -> bool;
let u32.Leq(self: u32, other: u32) -> bool;
let u32.Greq(self: u32, other: u32) -> bool;
let u32.And(self: u32, other: u32) -> u32;
let u32.Or(self: u32, other: u32) -> u32;
let u32.Lbs(self: u32, other: u32) -> u32;
let u32.Rbs(self: u32, other: u32) -> u32;

let u32.Incr(self: *u32) -> u32;
let u32.Decr(self: *u32) -> u32;

let u32.New(self: *u32) -> void;
let u32.Copy(self: *u32, other: u32) -> u32;
let u32.AddEq(self: *u32, other: u32) -> u32;
let u32.SubEq(self: *u32, other: u32) -> u32;
let u32.MultEq(self: *u32, other: u32) -> u32;
let u32.DivEq(self: *u32, other: u32) -> u32;
let u32.ModEq(self: *u32, other: u32) -> u32;
let u32.AndEq(self: *u32, other: u32) -> u32;
let u32.OrEq(self: *u32, other: u32) -> u32;
let u32.XorEq(self: *u32, other: u32) -> u32;

// u64
let u64.Add(self: u64, other: u64) -> u64;
let u64.Sub(self: u64, other: u64) -> u64;
let u64.Mult(self: u64, other: u64) -> u64;
let u64.Div(self: u64, other: u64) -> u64;
let u64.Mod(self: u64, other: u64) -> u64;
let u64.Xor(self: u64, other: u64) -> u64;
let u64.Eq(self: u64, other: u64) -> bool;
let u64.Neq(self: u64, other: u64) -> bool;
let u64.Less(self: u64, other: u64) -> bool;
let u64.Great(self: u64, other: u64) -> bool;
let u64.Leq(self: u64, other: u64) -> bool;
let u64.Greq(self: u64, other: u64) -> bool;
let u64.And(self: u64, other: u64) -> u64;
let u64.Or(self: u64, other: u64) -> u64;
let u64.Lbs(self: u64, other: u64) -> u64;
let u64.Rbs(self: u64, other: u64) -> u64;

let u64.Incr(self: *u64) -> u64;
let u64.Decr(self: *u64) -> u64;

let u64.New(self: *u64) -> void;
let u64.Copy(self: *u64, other: u64) -> u64;
let u64.AddEq(self: *u64, other: u64) -> u64;
let u64.SubEq(self: *u64, other: u64) -> u64;
let u64.MultEq(self: *u64, other: u64) -> u64;
let u64.DivEq(self: *u64, other: u64) -> u64;
let u64.ModEq(self: *u64, other: u64) -> u64;
let u64.AndEq(self: *u64, other: u64) -> u64;
let u64.OrEq(self: *u64, other: u64) -> u64;
let u64.XorEq(self: *u64, other: u64) -> u64;

// u128
let u128.Add(self: u128, other: u128) -> u128;
let u128.Sub(self: u128, other: u128) -> u128;
let u128.Mult(self: u128, other: u128) -> u128;
let u128.Div(self: u128, other: u128) -> u128;
let u128.Mod(self: u128, other: u128) -> u128;
let u128.Xor(self: u128, other: u128) -> u128;
let u128.Eq(self: u128, other: u128) -> bool;
let u128.Neq(self: u128, other: u128) -> bool;
let u128.Less(self: u128, other: u128) -> bool;
let u128.Great(self: u128, other: u128) -> bool;
let u128.Leq(self: u128, other: u128) -> bool;
let u128.Greq(self: u128, other: u128) -> bool;
let u128.And(self: u128, other: u128) -> u128;
let u128.Or(self: u128, other: u128) -> u128;
let u128.Lbs(self: u128, other: u128) -> u128;
let u128.Rbs(self: u128, other: u128) -> u128;

let u128.Incr(self: *u128) -> u128;
let u128.Decr(self: *u128) -> u128;

let u128.New(self: *u128) -> void;
let u128.Copy(self: *u128, other: u128) -> u128;
let u128.AddEq(self: *u128, other: u128) -> u128;
let u128.SubEq(self: *u128, other: u128) -> u128;
let u128.MultEq(self: *u128, other: u128) -> u128;
let u128.DivEq(self: *u128, other: u128) -> u128;
let u128.ModEq(self: *u128, other: u128) -> u128;
let u128.AndEq(self: *u128, other: u128) -> u128;
let u128.OrEq(self: *u128, other: u128) -> u128;
let u128.XorEq(self: *u128, other: u128) -> u128;


// i8
let i8.Add(self: i8, other: i8) -> i8;
let i8.Sub(self: i8, other: i8) -> i8;
let i8.Mult(self: i8, other: i8) -> i8;
let i8.Div(self: i8, other: i8) -> i8;
let i8.Mod(self: i8, other: i8) -> i8;
let i8.Xor(self: i8, other: i8) -> i8;
let i8.Eq(self: i8, other: i8) -> bool;
let i8.Neq(self: i8, other: i8) -> bool;
let i8.Less(self: i8, other: i8) -> bool;
let i8.Great(self: i8, other: i8) -> bool;
let i8.Leq(self: i8, other: i8) -> bool;
let i8.Greq(self: i8, other: i8) -> bool;
let i8.And(self: i8, other: i8) -> i8;
let i8.Or(self: i8, other: i8) -> i8;
let i8.Lbs(self: i8, other: i8) -> i8;
let i8.Rbs(self: i8, other: i8) -> i8;

let i8.Incr(self: *i8) -> i8;
let i8.Decr(self: *i8) -> i8;

let i8.New(self: *i8) -> void;
let i8.Copy(self: *i8, other: i8) -> i8;
let i8.AddEq(self: *i8, other: i8) -> i8;
let i8.SubEq(self: *i8, other: i8) -> i8;
let i8.MultEq(self: *i8, other: i8) -> i8;
let i8.DivEq(self: *i8, other: i8) -> i8;
let i8.ModEq(self: *i8, other: i8) -> i8;
let i8.AndEq(self: *i8, other: i8) -> i8;
let i8.OrEq(self: *i8, other: i8) -> i8;
let i8.XorEq(self: *i8, other: i8) -> i8;

// i16
let i16.Add(self: i16, other: i16) -> i16;
let i16.Sub(self: i16, other: i16) -> i16;
let i16.Mult(self: i16, other: i16) -> i16;
let i16.Div(self: i16, other: i16) -> i16;
let i16.Mod(self: i16, other: i16) -> i16;
let i16.Xor(self: i16, other: i16) -> i16;
let i16.Eq(self: i16, other: i16) -> bool;
let i16.Neq(self: i16, other: i16) -> bool;
let i16.Less(self: i16, other: i16) -> bool;
let i16.Great(self: i16, other: i16) -> bool;
let i16.Leq(self: i16, other: i16) -> bool;
let i16.Greq(self: i16, other: i16) -> bool;
let i16.And(self: i16, other: i16) -> i16;
let i16.Or(self: i16, other: i16) -> i16;
let i16.Lbs(self: i16, other: i16) -> i16;
let i16.Rbs(self: i16, other: i16) -> i16;

let i16.Incr(self: *i16) -> i16;
let i16.Decr(self: *i16) -> i16;

let i16.New(self: *i16) -> void;
let i16.Copy(self: *i16, other: i16) -> i16;
let i16.AddEq(self: *i16, other: i16) -> i16;
let i16.SubEq(self: *i16, other: i16) -> i16;
let i16.MultEq(self: *i16, other: i16) -> i16;
let i16.DivEq(self: *i16, other: i16) -> i16;
let i16.ModEq(self: *i16, other: i16) -> i16;
let i16.AndEq(self: *i16, other: i16) -> i16;
let i16.OrEq(self: *i16, other: i16) -> i16;
let i16.XorEq(self: *i16, other: i16) -> i16;

// i32
let i32.Add(self: i32, other: i32) -> i32;
let i32.Sub(self: i32, other: i32) -> i32;
let i32.Mult(self: i32, other: i32) -> i32;
let i32.Div(self: i32, other: i32) -> i32;
let i32.Mod(self: i32, other: i32) -> i32;
let i32.Xor(self: i32, other: i32) -> i32;
let i32.Eq(self: i32, other: i32) -> bool;
let i32.Neq(self: i32, other: i32) -> bool;
let i32.Less(self: i32, other: i32) -> bool;
let i32.Great(self: i32, other: i32) -> bool;
let i32.Leq(self: i32, other: i32) -> bool;
let i32.Greq(self: i32, other: i32) -> bool;
let i32.And(self: i32, other: i32) -> i32;
let i32.Or(self: i32, other: i32) -> i32;
let i32.Lbs(self: i32, other: i32) -> i32;
let i32.Rbs(self: i32, other: i32) -> i32;

let i32.Incr(self: *i32) -> i32;
let i32.Decr(self: *i32) -> i32;

let i32.New(self: *i32) -> void;
let i32.Copy(self: *i32, other: i32) -> i32;
let i32.AddEq(self: *i32, other: i32) -> i32;
let i32.SubEq(self: *i32, other: i32) -> i32;
let i32.MultEq(self: *i32, other: i32) -> i32;
let i32.DivEq(self: *i32, other: i32) -> i32;
let i32.ModEq(self: *i32, other: i32) -> i32;
let i32.AndEq(self: *i32, other: i32) -> i32;
let i32.OrEq(self: *i32, other: i32) -> i32;
let i32.XorEq(self: *i32, other: i32) -> i32;

// i64
let i64.Add(self: i64, other: i64) -> i64;
let i64.Sub(self: i64, other: i64) -> i64;
let i64.Mult(self: i64, other: i64) -> i64;
let i64.Div(self: i64, other: i64) -> i64;
let i64.Mod(self: i64, other: i64) -> i64;
let i64.Xor(self: i64, other: i64) -> i64;
let i64.Eq(self: i64, other: i64) -> bool;
let i64.Neq(self: i64, other: i64) -> bool;
let i64.Less(self: i64, other: i64) -> bool;
let i64.Great(self: i64, other: i64) -> bool;
let i64.Leq(self: i64, other: i64) -> bool;
let i64.Greq(self: i64, other: i64) -> bool;
let i64.And(self: i64, other: i64) -> i64;
let i64.Or(self: i64, other: i64) -> i64;
let i64.Lbs(self: i64, other: i64) -> i64;
let i64.Rbs(self: i64, other: i64) -> i64;

let i64.Incr(self: *i64) -> i64;
let i64.Decr(self: *i64) -> i64;

let i64.New(self: *i64) -> void;
let i64.Copy(self: *i64, other: i64) -> i64;
let i64.AddEq(self: *i64, other: i64) -> i64;
let i64.SubEq(self: *i64, other: i64) -> i64;
let i64.MultEq(self: *i64, other: i64) -> i64;
let i64.DivEq(self: *i64, other: i64) -> i64;
let i64.ModEq(self: *i64, other: i64) -> i64;
let i64.AndEq(self: *i64, other: i64) -> i64;
let i64.OrEq(self: *i64, other: i64) -> i64;
let i64.XorEq(self: *i64, other: i64) -> i64;

// i128
let i128.Add(self: i128, other: i128) -> i128;
let i128.Sub(self: i128, other: i128) -> i128;
let i128.Mult(self: i128, other: i128) -> i128;
let i128.Div(self: i128, other: i128) -> i128;
let i128.Mod(self: i128, other: i128) -> i128;
let i128.Xor(self: i128, other: i128) -> i128;
let i128.Eq(self: i128, other: i128) -> bool;
let i128.Neq(self: i128, other: i128) -> bool;
let i128.Less(self: i128, other: i128) -> bool;
let i128.Great(self: i128, other: i128) -> bool;
let i128.Leq(self: i128, other: i128) -> bool;
let i128.Greq(self: i128, other: i128) -> bool;
let i128.And(self: i128, other: i128) -> i128;
let i128.Or(self: i128, other: i128) -> i128;
let i128.Lbs(self: i128, other: i128) -> i128;
let i128.Rbs(self: i128, other: i128) -> i128;

let i128.Incr(self: *i128) -> i128;
let i128.Decr(self: *i128) -> i128;

let i128.New(self: *i128) -> void;
let i128.Copy(self: *i128, other: i128) -> i128;
let i128.AddEq(self: *i128, other: i128) -> i128;
let i128.SubEq(self: *i128, other: i128) -> i128;
let i128.MultEq(self: *i128, other: i128) -> i128;
let i128.DivEq(self: *i128, other: i128) -> i128;
let i128.ModEq(self: *i128, other: i128) -> i128;
let i128.AndEq(self: *i128, other: i128) -> i128;
let i128.OrEq(self: *i128, other: i128) -> i128;
let i128.XorEq(self: *i128, other: i128) -> i128;
