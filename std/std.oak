/*
Jordan Dehmel, 2023
Linkage file for the Oak standard package.
*/

include!(
    "std/std_io.oak",
    "std/std_conv.oak",
    "std/std_ops.oak"
);

link!("std/misc_std.o");

// Access rules
new_rule!("access_1", "; $*p [ $*a ]", "; $p . . Get ( $a )");
new_rule!("access_2", "^ $*p [ $*a ]", "^ $p . . Get ( $a )");
new_rule!("access_3", "@ $*p [ $*a ]", "@ $p . . Get ( $a )");
new_rule!("access_4", ", $*p [ $*a ]", ", $p . . Get ( $a )");
new_rule!("access_5", "[ $*p [ $*a ]", "[ $p . . Get ( $a )");
new_rule!("access_6", "] $*p [ $*a ]", "] $p . . Get ( $a )");
new_rule!("access_7", "( $*p [ $*a ]", "( $p . . Get ( $a )");
new_rule!("access_8", ") $*p [ $*a ]", ") $p . . Get ( $a )");
new_rule!("access_9", "{ $*p [ $*a ]", "{ $p . . Get ( $a )");
new_rule!("access_10", "} $*p [ $*a ]", "} $p . . Get ( $a )");
bundle_rule!("access",
    "access_1",
    "access_2",
    "access_3",
    "access_4",
    "access_5",
    "access_6",
    "access_7",
    "access_8",
    "access_9",
    "access_10");

// Void return rule
new_rule!("void_return", "let $a ( $*b ) {", "let $a ( $b ) -> void {");

// Auto-parenthesize rules
new_rule!("auto_if_paren", "if $*a {", "if ( $a ) {");
new_rule!("auto_while_paren", "while $*a {", "while ( $a ) {");

// Method rules
new_rule!("argless_mut_method", "$a . . $b ( )", "$b ( @ $a )");
new_rule!("mut_method", "$a . . $b (", "$b ( @ $a ,");
new_rule!("argless_method", "$a . $b ( )", "$b ( $a )");
new_rule!("const_method", "$a . $b (", "$b ( $a ,");

// Definition-Instantiation rule
new_rule!("def_init", "let $a : $b = ", "let $a : $b ; $a = ");

// For loop rule
new_rule!("for",
    "for ( $*a ; $*b ; $*c ) { $*d }",
    "{ $a ; while ( $b ) { $d $c ; } }");

bundle_rule!("std",
    "void_return",
    "auto_if_paren",
    "auto_while_paren",
    "argless_mut_method",
    "mut_method",
    "argless_method",
    "const_method",
    "def_init",
    "for");

// Misc
let time() -> i64;

// Seeds RNG with current time
let seed_rand() -> void;

// Seeds RNG with a given number
let seed_rand(with: i32) -> void;

// Generates a random number
let rand(low: i32, high: i32) -> i32;

// Get the ctime version of a time
let c_time(when: i32) -> str;
let c_time(when: i64) -> str;

// Run a system command
let sys(command: str) -> i32;

let unit: struct;

/*
Takes a format string and some number of
other things.

Any percentage sign % in the format string
will be replaced by the corrosponding thing.
Note that this does not use the C system
of types- a % will print whatever's next
no matter what.

For instance:

`Oak`:
```
package!("std");
use_rule!("std");

let main() -> i32
{
    let i: i32 = 123;
    let j: f64 = 1.234;

    printf!(
        "Variable i is %, j is %, and some text is '%'.\n",
        i,
        j,
        "some text here"
    );

    0
}

```

`Output`:
```
Variable i is 123, j is 1.234, and some text is 'some text here'.
```

You can escape this behaviour for a literal
% via the backslash.
*/
let printf!(argc: i32, argv: *str) -> i32
{
    // Include ONLY IO so as to avoid recursion
    include!("std/std_io.oak");
    include!("std/std_conv.oak");

    // It should be recursion-safe to use this rule here
    use_rule!("std");

    if (argc == 1)
    {
        print("print(");
        print(Get(@argv, 1));
        print(");\n");
    }
    else
    {
        let cur_char: i32 = 0;
        let cur_arg: i32 = 1;

        // Iterate through
        for (let cur_char: i32 = 0; Get(Get(@argv, 1), cur_char) != to_i8(0); cur_char += 1)
        {
            let cur: i8 = Get(Get(@argv, 1), cur_char);

            if (cur == to_i8())
            {

            }
        }
    }

    0
}
