// A test of the end-goal of Oak generics
// Basics are passed, but goals are still lofty

package!("std");
use_rule!("std");

let pair<l, r>: struct
{
    first: l,
    second: r,
}

/*
inst
{
    New<l, r>;
    Copy<l, r>;
    Del<l, r>;
}

// The inst block is theoretical right now.
// (inst is short for instantiation).
// It will be sequenced and discarded upon template
// instantiation. This is Oak's solution to the lack
// of methods at struct definition.
*/

let New<l, r>(self: ^pair<l, r>) -> void
{
    New(@self.first);
    New(@self.second);
}

let Copy<l, r>(self: ^pair<l, r>, first: l, second: r) -> void
{
    self.first = first;
    self.second = second;
}

let Copy<l, r>(self: ^pair<l, r>, other: pair<l, r>) -> void
{
    self.first = other.first;
    self.second = other.second;
}

let Del<l, r>(self: ^pair<l, r>) -> void
{
    Del(@self.first);
    Del(@self.second);
}

let make_pair<l, r>(first: l, second: r) -> pair<l, r>
{
    let out: pair<l, r>;

    out.first = first;
    out.second = second;

    out
}

let main() -> i32
{
    // We want the following lines to be needless
    New<i32, i32>;
    Copy<i32, i32>;

    let inst: pair<i32, i32>;

    inst = make_pair<i32, i32>(123, 456);

    print(inst.first);
    print('\n');
    print(inst.second);
    print('\n');

    // Of course, you don't actually need make_pair,
    // so long as you've instantiated the appropriate
    // Copy operator. This is an actually cool part 
    // of Oak.

    inst = (789, 123);

    print(inst.first);
    print('\n');
    print(inst.second);
    print('\n');

    0
}
