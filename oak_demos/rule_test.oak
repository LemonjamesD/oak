// Testing of Oak's std_method rule (and rules in general)
// Legacy passed

package!("std");

/*
// Experimental bundle for method declarations

new_rule!("mut_meth_dec", "let $a . . $b ( )", "let $b ( self : ^ $a )");
new_rule!("const_meth_dec", "let $a . $b ( )", "let $b ( self : $a )");
new_rule!("mut_arg_meth_dec", "let $a . . $b (", "let $b ( self : ^ $a ,");
new_rule!("const_arg_meth_dec", "let $a . $b (", "let $b ( self : $a ,");

bundle_rule!("std_method_dec",
    "mut_meth_dec",
    "const_meth_dec",
    "mut_arg_meth_dec",
    "const_arg_meth_dec");

use_rule!("std_method_dec");
*/

use_rule!("std_method");

let times_two(self: ^i32) -> i32
{
    (^self * 2)
}

let times_two(self: i32) -> i32
{
    (self * 100)
}

let times(self: i32, other: i32, other_other: i32) -> i32
{
    (self * other * other_other)
}

let main() -> i32
{
    let a: i32;
    a = 5;

    print(a..times_two());
    print("\n");

    print(a.times_two());
    print("\n");

    print(a.times(10, 10));
    print("\n");

    0
}
